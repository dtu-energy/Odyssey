from odyssey.navigators import Navigator
import torch
from botorch.utils.sampling import draw_sobol_samples
import random

class Random_Navigator(Navigator):

    """
    Random_Navigator is a subclass of the Navigator class that uses random sampling. 
    The Random_Navigator can serve dual purposes: it can be used for initialization and can also function independently as a standalone navigator. 
    The Random_Navigator does not necessitate the provision of initial data. As it inherits from the Navigator class, it utilizes the initialization parameters of the Navigator for its own initialization.

    Attributes:
        requires_init_data (bool): A flag, set to False, indicating that this navigator does not require initial data.
        samples_generated (int): The number of samples generated by the navigator.
    """

    requires_init_data = False

    def __init__(self,
                 seed=None,
                 *args,
                 **kwargs):
        
        """
        Initializes a Random_Navigator object. 

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        
        super().__init__(*args, **kwargs)

        self.current_sample = 0
        # self.seed = seed
    
    def _upgrade(self):

        """
        Simply increments the number of samples generated by the navigator.
        """

        self.current_sample += 1

    def _trajectory(self) -> torch.Tensor:

        """
        Draws a random sample.

        Returns:
            torch.Tensor: The next sample.
        """

        try:
            candidate = self.sequence[self.current_sample][None, :] # have to add new axis because train_X has a 0 axis
        except IndexError as e:
            raise IndexError("sobol sequence exhausted")

        return candidate

    def _get_next_trial(self) -> torch.Tensor:

        """
        Draws a random sample.

        Returns:
            torch.Tensor: The next sample.
        """

        candidate = torch.rand(self.mission.param_dims) * self.mission.envelope.T[1]

        return candidate[None, :]